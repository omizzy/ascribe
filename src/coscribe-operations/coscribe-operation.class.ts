import CodeOwnersFile from '../core/codeowners-file.class';
import CoscribeConfig from '../core/coscribe-config.class';
import FileEntry from '../core/file-entry.class';
import GitFileList from '../core/git-file-list.class';
import CoscribeGitInterface from '../git-adapters/coscribe-git.interface';
import CoscribeProgressInterface from '../progress-adapters/coscribe-progress.interface';
import { FORMAT } from '../progress-adapters/format-type.enum';
import { CoscribeOperationResult } from '../types/coscribe-operation-result.type';

/**
 *
 */
export default abstract class CoscribeOperation {
    /**
     *
     */
    protected codeOwnersFile: CodeOwnersFile;

    /**
     *
     * @param coscribeConfig
     */
    constructor(
        protected readonly gitAdapter: CoscribeGitInterface,
        protected readonly coscribeConfig: CoscribeConfig,
    ) {
        const codeOwnersFilePath = this.coscribeConfig.getCodeOwnersFilePath();
        this.codeOwnersFile = new CodeOwnersFile(codeOwnersFilePath);
    }

    public getFileEntry(file: string): FileEntry {
        let fileEntry: FileEntry;
        if (this.coscribeConfig.isPresetFile(file)) {
            fileEntry = this.getPresetFileEntry(file);
        } else {
            fileEntry = this.getAutogeneratedFileEntry(file);
        }
        return fileEntry;
    }

    /**
     *
     * @param file
     * @returns
     */
    private getPresetFileEntry(file: string): FileEntry {
        const authors = new Set<string>(
            this.coscribeConfig.getPresetFile(file),
        );
        return new FileEntry(file, authors);
    }

    /**
     *
     * @param file
     * @returns
     */
    private getAutogeneratedFileEntry(file: string): FileEntry {
        const fileAuthors = this.gitAdapter.getTrackedFileAuthors(file);
        const authors = new Set<string>();
        for (const author of fileAuthors) {
            if (this.coscribeConfig.isOmittedAuthor(author)) {
                continue;
            }
            authors.add(this.coscribeConfig.isAuthorRemapped(author) ?? author);
        }
        return new FileEntry(file, authors);
    }

    protected processPresetDirectories(
        progressTracker?: CoscribeProgressInterface,
    ): void {
        progressTracker?.reset(FORMAT.DIRECTORIES);
        const presetDirectories = Object.entries(
            this.coscribeConfig.getPresetDirectories(),
        );
        const directories = [];
        if (presetDirectories.length) {
            progressTracker?.start({
                start: 0,
                total: presetDirectories.length,
            });
            let dirCount = 0;
            for (const [directory, authors] of presetDirectories) {
                const hasAuthors = !!authors.length;
                let status = `Processing preset directory pattern ${directory}`;

                if (!hasAuthors) {
                    status = `Skip: No authors found for directory pattern ${directory}`;
                }
                progressTracker?.update({
                    progress: ++dirCount,
                    status,
                });
                if (!hasAuthors) {
                    continue;
                }
                this.codeOwnersFile.upsertFileEntry(
                    new FileEntry(directory, new Set<string>(authors)),
                );
                directories.push(directory);
            }
            progressTracker?.update({
                progress: dirCount,
                status: `Done`,
            });
            progressTracker?.complete();
        }
    }

    protected processFiles(
        files: GitFileList,
        progressTracker?: CoscribeProgressInterface,
    ) {
        progressTracker?.reset(FORMAT.FILES);
        let count = 0;
        progressTracker?.start({
            start: count,
            total: files.length,
        });
        for (const file of files) {
            let status = `Processing file ${file}`;
            const fileOmitted =
                this.coscribeConfig.isFileOmittedByPattern(file);
            if (fileOmitted) {
                status = `Skip: Omission detected for file ${file}`;
            }
            const fileOmittedPreset =
                this.coscribeConfig.isFileOmittedByDirectoryPattern(file);
            if (fileOmittedPreset) {
                status = `Skip: Preset pattern detected for file ${file}`;
            }
            const fileEntry = this.getFileEntry(file);
            const hasAuthors = !!fileEntry.getAuthors().size;
            if (!hasAuthors) {
                status = `Skip: No authors resolved for file ${file}`;
            }
            progressTracker?.update({
                progress: ++count,
                status,
            });
            if (fileOmitted || fileOmittedPreset || !hasAuthors) {
                continue;
            }
            this.codeOwnersFile.upsertFileEntry(fileEntry);
        }
        this.codeOwnersFile.clear();
        this.codeOwnersFile.commit();
        progressTracker?.update({
            progress: count,
            status: `Done`,
        });
        progressTracker?.complete();

        return {
            files: count,
        };
    }

    /**
     *
     */
    abstract execute(
        progressTracker?: CoscribeProgressInterface,
    ): CoscribeOperationResult;
}
